/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Lure.jj */
/*@egen*/options {
                                                  
  OUTPUT_DIRECTORY="src/forkbomb/frontend";
                                                               
               
}

PARSER_BEGIN(LureParser)
  package forkbomb.frontend;

  import wci.intermediate.*;
  import forkbomb.intermediate.SymTabFactory;
  import forkbomb.intermediate.symtabimpl.*;

  import static forkbomb.intermediate.symtabimpl.SymTabKeyImpl.*;
  import static forkbomb.intermediate.symtabimpl.DefinitionImpl.*;
  import static forkbomb.intermediate.symtabimpl.SymTabKeyImpl.*;
  import static forkbomb.intermediate.icodeimpl.ICodeKeyImpl.*;

  public class LureParser/*@bgen(jjtree)*/implements LureParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTLureParserState jjtree = new JJTLureParserState();

/*@egen*/

    private static final String SOURCE_SUFFIX = ".lure";
    private static final String OUTPUT_SUFFIX = ".j";

    private static SymTabStack symTabStack;
    private static SymTabEntry programId;

    /* Print parse logs or not */
    private static boolean noisy = false;

    public static void main(String[] args) {
      try {
        /* Create and initialize the symbol table stack. */
        symTabStack = SymTabFactory.createSymTabStack();
        Predefined.initialize(symTabStack);

        /* Lure Parser reads the filename from the first argument. */
        LureParser parser = new LureParser(new java.io.FileInputStream(args[0]));
        SimpleNode script = parser.Script();
        script.dump(">");

        //cross-reference table.
        /* CrossReferencer crossReferencer = new CrossReferencer(); */
        /* crossReferencer.print(symTabStack); */
      }
      catch (ParseException e) { e.printStackTrace(); }
      catch (java.io.FileNotFoundException e) {
        System.err.println("Input file " + args[0] + " not found.");
      }
    }

    private static void visit(String construct) {
      if (noisy) {
        for (int i = 0; i <= nesting; i++) System.out.print("  ");
        System.out.println(construct + ": Visiting");
      }
    }

    private static void enter(String construct) {
      if (noisy) {
        for (int i = 0; i <= nesting; i++) System.out.print("  ");
        System.out.println(construct + ": Entering");
        nesting++;
      }
    }
    private static void leave(String construct) {
      if (noisy) {
        for (int i = 0; i <= nesting; i++) System.out.print("  ");
        System.out.println(construct + ": Leaving");
        nesting--;
      }
    }
    private static int nesting = 0;
  }
PARSER_END(LureParser)

  SKIP : {
    <IGNORE: [" "]>
      | <NEWLINE : "\n">
      | <LINECOMMENT: "#" (~["\n"])* "\n">
  }

// Keywords
TOKEN: {
 <END        : "end">
 | <IF         : "if">
 | <THEN       : "then">
 | <ELSE       : "else">
 | <LOOP       : "loop">
 | <WHILE      : "while">
 | <DO         : "do">
 | <BREAK      : "break">
 | <ASSIGN     : ":=">
 // Function Synonyms
 | <FN         : "fn">
 | <FUN        : "fun">
 | <FUNC       : "func">
 | <FUNCTION   : "function">
 | <STAB       : "->">
}

// Literals
TOKEN : {
  <NUMBER     : (<DIGIT>)+>
  | <DIGIT      : ["0" - "9"]>
  | <QUOTE      : "'"> : STRING_STATE
}

// Identifiers
TOKEN: {
  <IDENTIFIER : ["a" - "z", "A" - "Z", "_", "=", "+", "-", "*", "?", "$", "%", ">", "<"] ( ["a" - "z", "A" - "Z", "0" - "9", "_", "=", "+", "-", "*", "?", "$", "%", ">", "<"] )*>
}

<STRING_STATE> TOKEN:
{
  <STRING_CHAR: ~["'"]>
  | <ENDQUOTE : <QUOTE>> : DEFAULT
}

SimpleNode Script() : {/*@bgen(jjtree) Script */
  SimpleNode jjtn000 = new SimpleNode(JJTSCRIPT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Script */
  try {
/*@egen*/
  { enter("SCRIPT"); }
  ( Expression() )+ <EOF>
  { leave("SCRIPT"); }/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Expression()       : {}
{
  (LOOKAHEAD(2) AssignmentExpression() | LOOKAHEAD(2) FunctionInvocationExpression() |  FunctionLiteralExpression() | ConditionalExpression() | WhileExpression() | LoopExpression() | <IDENTIFIER> | <NUMBER> | String() )
}

SimpleNode ConditionalExpression() : {/*@bgen(jjtree) ConditionalExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConditionalExpression */
  try {
/*@egen*/
  { enter("CONDITIONAL"); }
  <IF> Expression() <THEN> Expression() ( <ELSE> Expression() { visit("ELSE"); })? <END> {
    return jjtn000;
  }/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { leave("CONDITIONAL"); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

SimpleNode  LoopExpression() : {/*@bgen(jjtree) LoopExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTLOOPEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LoopExpression */
  try {
/*@egen*/
  { enter("LOOP"); }
  <LOOP> <DO> ( LoopInteriorExpression() )* <END> {
    return jjtn000;
  }/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { leave("LOOP"); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void WhileExpression() : {/*@bgen(jjtree) WhileExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileExpression */
  try {
/*@egen*/
  { enter("WHILE"); }
  <WHILE> Expression() <DO> ( LoopInteriorExpression() )* <END>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { leave("WHILE"); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void LoopInteriorExpression()       : {}
{
  // TODO Allow BreakExpression() again after doing scoping.
  Expression()
}

void BreakExpression() : {/*@bgen(jjtree) BreakExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTBREAKEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BreakExpression */
  try {
/*@egen*/
  <BREAK> "("  Expression() ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void String() : {/*@bgen(jjtree) String */
                  SimpleNode jjtn000 = new SimpleNode(JJTSTRING);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ StringBuilder builder = new StringBuilder(); }
{/*@bgen(jjtree) String */
  try {
/*@egen*/
  { enter("STRING"); }
  <QUOTE> (StringCharacter(builder))* <ENDQUOTE>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { leave("STRING"); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void StringCharacter(StringBuilder builder)       : { Token t; }
{
  t = <STRING_CHAR>
  { builder.append(t.image.charAt(0)); }
}

void AssignmentExpression() : {/*@bgen(jjtree) AssignmentExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignmentExpression */
  try {
/*@egen*/
  { enter("ASSIGNMENT"); }
    <IDENTIFIER> <ASSIGN> Expression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { leave("ASSIGNMENT"); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
  }

  void FunctionStart() : {/*@bgen(jjtree) FunctionStart */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
  {/*@bgen(jjtree) FunctionStart */
    try {
/*@egen*/
    <FN> | <FUN> | <FUNC> | <FUNCTION> | <STAB>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
  }

  void FunctionLiteralExpression() : {/*@bgen(jjtree) FunctionLiteralExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONLITERALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
  {/*@bgen(jjtree) FunctionLiteralExpression */
    try {
/*@egen*/
    { enter("FUNCTION"); }
    FunctionStart() ArgumentList() "{" ( FunctionInteriorExpression() )* "}"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { leave("FUNCTION"); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
  }

  void FunctionInteriorExpression()             : {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
  {/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    // TODO: Add support for ReturnExpression()
    Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
  }

  void ArgumentList() : {/*@bgen(jjtree) ArgumentList */
  SimpleNode jjtn000 = new SimpleNode(JJTARGUMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
  {/*@bgen(jjtree) ArgumentList */
    try {
/*@egen*/
    "(" ( <IDENTIFIER> ( "," <IDENTIFIER> )* )? ")"/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
  }

  void FunctionInvocationExpression() : {/*@bgen(jjtree) FunctionInvocationExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONINVOCATIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
  {/*@bgen(jjtree) FunctionInvocationExpression */
    try {
/*@egen*/
    { enter("INVOCATION"); }
    <IDENTIFIER> "(" ( Expression() ( "," Expression() )? )? ")"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { leave("INVOCATION"); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
  }
