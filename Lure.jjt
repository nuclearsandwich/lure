options {
  JJTREE_OUTPUT_DIRECTORY="src/forkbomb/frontend";
  OUTPUT_DIRECTORY="src/forkbomb/frontend";
  VISITOR=true;
  MULTI=true;
}

PARSER_BEGIN(LureParser)
  package forkbomb.frontend;

  import java.util.ArrayList;

  import wci.intermediate.ICodeNode;
  import forkbomb.backend.LureCompiler;

  public class LureParser {

    public static void main(String[] args) {
      try {
        /* Lure Parser reads the filename from the first argument. */
        LureParser parser = new LureParser(new java.io.FileInputStream(args[0]));
        SimpleNode script = parser.Script();
        script.dump(">");
        LureASTParser ast = new LureASTParser();
        ICodeNode root = ast.parse(script);
        LureCompiler compiler = new LureCompiler();
        compiler.printICTree(root);
        compiler.compile(root);
      }
      catch (ParseException e) { e.printStackTrace(); }
      catch (java.io.FileNotFoundException e) {
        System.err.println("Input file " + args[0] + " not found.");
      }
    }

    private static void visit(String construct) {
      if (noisy) {
        for (int i = 0; i <= nesting; i++) System.out.print("  ");
        System.out.println(construct + ": Visiting");
      }
    }

    private static void enter(String construct) {
      if (noisy) {
        for (int i = 0; i <= nesting; i++) System.out.print("  ");
        System.out.println(construct + ": Entering");
        nesting++;
      }
    }
    private static void leave(String construct) {
      if (noisy) {
        for (int i = 0; i <= nesting; i++) System.out.print("  ");
        System.out.println(construct + ": Leaving");
        nesting--;
      }
    }
    private static int nesting = 0;
    private static boolean noisy = false;
  }
PARSER_END(LureParser)

  SKIP : {
    <IGNORE: [" "]>
      | <NEWLINE : "\n">
      | <LINECOMMENT: "#" (~["\n"])* "\n">
  }

// Keywords
TOKEN: {
 <END        : "end">
 | <IF         : "if">
 | <THEN       : "then">
 | <ELSE       : "else">
 | <LOOP       : "loop">
 | <WHILE      : "while">
 | <DO         : "do">
 | <BREAK      : "break">
 | <ASSIGN     : ":=">
 // Function Synonyms
 | <FN         : "fn">
 | <FUN        : "fun">
 | <FUNC       : "func">
 | <FUNCTION   : "function">
 | <STAB       : "->">
}

// Literals
TOKEN : {
  <NUMBER     : (<DIGIT>)+>
  | <DIGIT      : ["0" - "9"]>
  | <QUOTE      : "'"> : STRING_STATE
}

// Identifiers
TOKEN: {
  <IDENTIFIER : ["a" - "z", "A" - "Z", "_", "=", "+", "-", "*", "?", "$", "%", ">", "<"] ( ["a" - "z", "A" - "Z", "0" - "9", "_", "=", "+", "-", "*", "?", "$", "%", ">", "<"] )*>
}

<STRING_STATE> TOKEN:
{
  <STRING_CHAR: ~["'"]>
  | <ENDQUOTE : <QUOTE>> : DEFAULT
}

SimpleNode Script() : {}
{
  { enter("SCRIPT"); }
  ( Expression() )+ <EOF>
  { leave("SCRIPT"); }
  { return jjtThis; }
}

void Expression() #void : {}
{
  (LOOKAHEAD(2) AssignmentExpression() | LOOKAHEAD(2) FunctionInvocationExpression() |  FunctionLiteralExpression() | ConditionalExpression() | WhileExpression() | LoopExpression() | VariableAccess() | Number() | String() )
}

SimpleNode ConditionalExpression() : {}
{
  { enter("CONDITIONAL"); }
  <IF> Expression() <THEN> Expression() ( <ELSE> Expression() { visit("ELSE"); })? <END> {
    return jjtThis;
  }
  { leave("CONDITIONAL"); }

}

SimpleNode LoopExpression() : {}
{
  { enter("LOOP"); }
  <LOOP> <DO> ( LoopInteriorExpression() )* <END> {
    return jjtThis;
  }
  { leave("LOOP"); }
}

SimpleNode WhileExpression() : {}
{
  { enter("WHILE"); }
  <WHILE> Expression() <DO> ( LoopInteriorExpression() )* <END> {
    return jjtThis;
  }
  { leave("WHILE"); }
}

void LoopInteriorExpression() #void : {}
{
  // TODO Allow BreakExpression() again after doing scoping.
  Expression()
}

SimpleNode Number() : {}
{
  <NUMBER> {
    jjtThis.jjtSetValue(token.image);
    return jjtThis;
  }
}

SimpleNode String() : { StringBuilder builder = new StringBuilder(); }
{
  { enter("STRING"); }
  <QUOTE> (StringCharacter(builder))* <ENDQUOTE> {
  jjtThis.jjtSetValue(builder.toString());
  return jjtThis;
  }
  { leave("STRING"); }
}

void StringCharacter(StringBuilder builder) #void : { Token t; }
{
  t = <STRING_CHAR>
  { builder.append(t.image.charAt(0)); }
}

SimpleNode AssignmentExpression() : {Token identifier;}
{
  { enter("ASSIGNMENT"); }
    identifier = <IDENTIFIER>
      <ASSIGN> Expression() {
      jjtThis.jjtSetValue(identifier.image);
      return jjtThis;
    }

  { leave("ASSIGNMENT"); }
}

void FunctionStart() #void : {}
{
  <FN> | <FUN> | <FUNC> | <FUNCTION> | <STAB>
}

void FunctionLiteralExpression() : {}
{
  { enter("FUNCTION"); }
  FunctionStart() ArgumentList() "{" ( FunctionInteriorExpression() )* "}"
  { leave("FUNCTION"); }
}

void FunctionInteriorExpression() #void : {}
{
  Expression()
}

SimpleNode ArgumentList() : { ArrayList<String> parameterList = new ArrayList<String>();}
{
  "(" ( <IDENTIFIER> {
    parameterList.add(token.image);
  } ( "," <IDENTIFIER> {
    parameterList.add(token.image);
  } )* )? ")" {
    jjtThis.jjtSetValue(parameterList);
    return jjtThis;
  }
}

void FunctionInvocationExpression() : {}
{
  { enter("INVOCATION"); }
  VariableAccess() "(" ( Expression() ( "," Expression() )? )? ")"
  { leave("INVOCATION"); }
}

SimpleNode VariableAccess() : {}
{
  { enter("VARIABLEACCESS"); }
    <IDENTIFIER> {
      jjtThis.jjtSetValue(token.image);
      return jjtThis;
    }
  { leave("VARIABLEACCESS"); }
}
